http://asciiflow.com/
https://refactoring.guru/design-patterns/

Strategy
========================================================================
Strategy is a behavioral design pattern that lets you define a family of 
algorithms, put each of them into a separate class, and make their 
objects interchangeable.


+--------------------------------+                             +-----------------+
|            Context             |                             |  <<interface>>  |
+--------------------------------+                           * |    Strategy     |
| - strategy                     |---------------------------->------------------+
+--------------------------------+                             | + execute(data) |
| + setStrategy(strategy)        |                             +-----------------+
| + doSomethingWithTheStrategy() |                                      ^
+--------------------------------+                                      |
                ^                                                       |
                |                                 +------------------------------------------------+
                |                                 |                     |                          |
                |                                 |                     |                          |
                |                    +----------------------+  +----------------------+  +----------------------+
                |                    |  ConcreteStrategies  |  |  ConcreteStrategies  |  |  ConcreteStrategies  |
           +----+-----+              +----------------------+  +----------------------+  +----------------------+
           |  Client  +------------->|                      |  |                      |  |                      |
           +----------+              +-+--------------------+  +-+--------------------+  +-+--------------------+
                                     | + execute(data)      |  | + execute(data)      |  | + execute(data)      |
                                     +-+--------------------+  +-+--------------------+  +-+--------------------+




Observer
========================================================================
Observer is a behavioral design pattern that lets you define a 
subscription mechanism to notify multiple objects about any events that 
happen to the object theyâ€™re observing.


+--------------------------------+                             +-----------------+
|         Publisher              |                             |  <<interface>>  |
+--------------------------------+                             |    Subscriber   |
| - subscribers: Subscriber[]    +---------------------------->+-----------------+
| - mainState                    |                             | + update()      |
+--------------------------------+                             +-----------------+
| + subscribe(s: Subscriber)     |                                      ^
| + unsubscribe(s: Subscriber)   |                                      |
| + notifySubscribers()          |                                      |
| + mainBusinessLogic()          |                +----------------------<-------------------------+
+--------------------------------+                |                     |                          |
                 ^                                |                     |                          |
                 |                   +----------------------+  +----------------------+  +----------------------+
                 |                   |  ConcreteSubscribers |  |  ConcreteSubscribers |  |  ConcreteSubscribers |
           +----------+              +----------------------+  +----------------------+  +----------------------+
           |  Client  |              |                      |  |                      |  |                      |
           +----------+              +----------------------+  +----------------------+  +----------------------+
                                     | + update(publisher)  |  | + update(publisher)  |  | + update(publisher)  |
                                     +----------------------+  +----------------------+  +----------------------+




Factory Method
========================================================================
Factory Method is a creational design pattern that provides an interface 
for creating objects in a superclass, but allows subclasses to alter the 
type of objects that will be created.


                +----------------------------+                                +----------------+         
                |          Creator           |                                |  <<interface>> |         
                ------------------------------                                |     Product    |         
                | + someOperation()          |------------------------------->|-----------------         
                | + createProduct(): Product |                                |                |         
                +--------------------------- +                                +----------------+         
                              ^                                                       ^
                              |                                                       |                 
           -------------------+------------------                            ---------+----------       
           |                                    |                            |                  |       
           |                                    |                            |                  |       
           |                                    |                            |                  |       
+----------------------------+   +-----------------------------+       +-------------+   +--------------+
|       ConcreteCreatorA     |   |      ConcreteCreatorB       |       |  Concrete   |   |   Concrete   |
|----------------------------|   |-----------------------------|       |  ProductA   |   |   ProductB   |
| + createProduct(): Product |   | + createProduct(): Product  |       +-------------+   +--------------+
+----------------------------+   +-----------------------------+                                              
                                                                                                                    

Abstract Factory 
========================================================================
Abstract Factory is a creational design pattern that lets you produce 
families of related objects without specifying their concrete classes.


                                          +--------------------------------+
                                          |        ConcreteFactory1        |
                                          +--------------------------------+
       +--------------------+-------------+                                |
       |                    |             |  +createProductA(): ProductA   |
       |                    |             |  +createProductB(): ProductB   |
       v                    v             |                                |
+------+------+      +------+------+      +---------------+----------------+
|  Concrete   |      | Concrete    |                      |
|  ProductA1  |      | ProductB1   |                      |
+------+------+      +------+------+                      |
       |                    |                             v
       |                    |             +---------------+----------------+
       |                    |             |       << interface >>          |
       v                    v             |       AbstractFactory          |
+------+------+      +------+------+      +--------------------------------+
|  ProductA   |      |  ProductB   |      |                                |
+------+------+      +------+------+      |  +createProductA(): ProductA   |
       ^                    ^             |  +createProductB() :ProductB   |
       |                    |             |                                |
       |                    |             +---------------+----------------+
       |                    |                             ^
+------+------+      +------+------+                      |
| Concrete    |      | Concrete    |                      |
| ProductA2   |      | ProductB2   |                      |
+------+------+      +------+------+      +---------------+----------------+
       ^                    ^             |        ConcreteFactory2        |
       |                    |             +--------------------------------+
       |                    |             |                                |
       +--------------------+-------------+  +createProductA(): ProductA   |
                                          |  +createProductB(): ProductB   |
                                          |                                |
                                          +--------------------------------+



Decorator
========================================================================
Decorator is a structural design pattern that lets you attach new 
behaviors to objects by placing these objects inside special wrapper 
objects that contain the behaviors.

          +---------------+
          | <<interface>> |
          |   Component   |
          +---------------+
          |               |
          | +execute()    |
          |               |
          +-------+-------+
                  ^
                  |
        +--------------------------+
        |                          |
        |                          |
+-------+-------+    +-------------+--------------+
| Concrete      |    |       <<interface>>        |
| Component     |    |       Base Decorator       |
+---------------+    +----------------------------+
|               |    |                            |
| +execute()    |    |  +execute()                |
|               |    |                            |
+---------------+    +-------------+--------------+
                                   ^
                                   |
                                   |
                             +-----+------+
                             | Concrete   |
                             | Decorator  |
                             +------------+
                             |            |
                             | +execute() |
                             |            |
                             +------------+


Singleton
========================================================================
The Singleton pattern solves two problems at the same time, violating 
the Single Responsibility Principle:

1. Ensure that a class has just a single instance.                                                                                                 
2. Provide a global access point to that instance.

+----------------------------+
|        Singleton           |<--+
+-----------------------------   |
| - instance: Singleton      |   |
| - Singleton()              +---+
+-+--------------------------|
|                            |
| + getInstance(): Singleton |
+-+--------------------------+


Command
========================================================================
Command is a behavioral design pattern that turns a request into a 
stand-alone object that contains all information about the request. 
This transformation lets you parameterize methods with different 
requests, delay or queue a requestâ€™s execution, and support undoable 
operations.

                +-----------------+               +-----------------------+
                |  <<interface>>  |               |       Invoker         |
                |    Command      |             n +-----------------------+
                +-----------------+ <-------------+ command               |
                |                 |               +-----------------------+
                | +execute()      |               | setCommand(command)   |
                |                 |               | executeCommand()      |
                +--------+--------+               +-----------------------+
                         ^
                         |
                         |
            +------------+------------+
            |                         |
            |                         |
+-----------+---------+     +---------+------------+
|       Command1      |     |      Command2        |
+---------------------+     +----------------------+
| receiver1           |     | receiver2            |
+---------------------+     +----------------------+
| Command1(receiver1) |     | Command2(receiver2)  |
| execute()           |     | execute()            |
|                     |     |                      |
+----------+----------+     +---------+------------+
           |                          |
           |                          |
           v                          v
   +-------+-------+          +-------+-------+
   |   Receiver1   |          |   Receiver2   |
   +---------------+          +---------------+
   |               |          |               |
   +---------------+          +---------------+


Adapter
========================================================================
Converts the interface of one object so that another object can 
understand it.
An adapter wraps one of the objects to hide the complexity of conversion 
happening behind the scenes. The wrapped object isnâ€™t even aware of 
the adapter. 
It permits classes with incompatible interfaces to work together.



                     +--------------------+
                     |    <<interface>>   |
+----------+         |  Client Interface  |
| Client   +-------->|--------------------+
+----------+         | + method(data)     |
                     |                    |
                     +--------------------+
                               ^
                               |
                               |
                     +--------------------+          +----------------------+
                     |      Adapter       +--------->+      Service         |
                     +--------------------+          +----------------------+
                     | - adaptee: Service |          | ...                  |
                     |                    |          |                      |
                     +--------------------+          +----------------------+
                     | + method(data)     |          | + serviceMethod(...) |
                     |                    |          |                      |
                     +--------------------+          +----------------------+

- The Client is a class that contains the existing business logic of the program.
- The Client Interface describes a protocol that other classes must follow to be
able to collaborate with the client code.
- The Service is some useful class (usually 3rd-party of legacy). The client can't
use this class directly because it has an incompatible interface.
- The Adapter is a class that is able to work with both the client and the service:
it implements the client interface while wrapping the service object. The adapter
receives calls from the client via the adapter interface and translates them into
calls to the wrapped service object in a format it can understand.
- The Client code doesn't get coupled to the concrete adapter class as long as it
works with the adapter via the client interface.


Facade
========================================================================
Structural design pattern that provides a simplified interface to a
library, a framework, or any other complex set of classes.

                    +-----------------------------+           +--------------------------+
                    |           Facade            |           |    Additional Facade     |
                    +-----------------------------+           +--------------------------+
+----------+        | - linksToSubsystemObjects   |---------->| ...                      |
| Client   |------->| - optionalAdditionalFacade  |           |                          |
+----------+        +-----------------------------+           +--------------------------+
                    | + subsystemOperation()      |           | + anotherOpertion()      |
                    |                             |           |                          |
                    +-----------------------------+           +--------------------------+
                         |             |     |                        |
                         |             |     |                        |
                         |             |     |                        |
                         |             |     +---------+              |
                         |             |               |              |
                         v             v               v              v                            
                    +----+------+  +---+-------+  +-----------+  +----+------+
                    | Subsystem |  | Subsystem |  | Subsystem |  | Subsystem |
                    | class     |  | class     |  | class     |  | class     |
                    |           |  |           |  |           |  |           |
                    +-----------+  +-----------+  +-----------+  +-----------+

* Facade defines a new interface for existing objects, whereas Adapter tries to make the 
existing interface usable. Adapter usually wraps just one object, while Facade works 
with an entire subsystem of objects.



Template Method
========================================================================
Template Method is a behavioral design pattern that defines the skeleton 
of an algorithm in the superclass but lets subclasses override specific 
steps of the algorithm without changing its structure.

         +----------------------+
         |     AbstractClass    |
         +----------------------+
         | ...                  |     +----------------------+
         +----------------------+     | templateMethod() {   |
         | + templateMethod() --------|   step1();           |
         | + step1()            |     |   if(step2()) {      |
         | + step2()            |     |     step3()          |
         | + step3()            |     |   }                  |
         | + step4()            |     |   step4();           |
         +-----------+----------+     | }                    |
                     ^                +----------------------+
                     |
                     |
         +-----------+-----------+
         |                       |
+--------+--------+     +--------+--------+
| ConcreteClass1  |     | ConcreteClass2  |
+-----------------+     +-----------------+
| ...             |     | ...             |
+-+---------------+     +-+---------------+
| + step3()       |     | + step1()       |
| + step4()       |     | + step2()       |
+-----------------+     | + step3()       |
                        | + step4()       |
                        +-----------------+

Iterator
========================================================================
Iterator is a behavioral design pattern that lets you traverse elements 
of a collection without exposing its underlying representation (list, 
stack, tree, etc.).

                             +--------+
                  +----------+ Client +-------------+
                  |          +--------+             |
                  |                                 |
                  |                                 |
                  v                                 v
         +-------------------+           +------------------------------+
         |   <<interface>>   |           |        <<interface>>         |
         |     Iterator      |           |      IterableCollection      |
         +-------------------+           +------------------------------+
         | + getNext()       |<----------| + createIterator(): Iterator |
         | + hasMore(): bool |           +------------------------------+ 
         +--------+----------+                          ^
                  ^                                     |
                  |                                     |
                  |                                     |
                  |                                     |
+-----------------+----------------+            +------------------------------+
|    ConcreteIterator              |            |      ConcreteCollection      |
+----------------------------------+            +------------------------------+
| - collection: ConcreteCollection |----------->| ...                          |
| - iterationState                 |            +------------------------------+
+----------------------------------+            | ...                          |
| + ConcreteIteration(             |            | + createIterator(): Iterator |
|    c: ConcreteCollection)        |            +------------------------------+
| + getNext()                      |
| + hasMore(): bool                |
+----------------------------------+



Composite
========================================================================
Composite is a structural design pattern that lets you compose objects 
into tree structures and then work with these structures as if they were 
individual objects.

                    +---------+
                    | Client  |
                    +----+----+
                         |
                         |
                         v
                 +-------+--------+
                 |  <<interface>> |                            
                 |   Component    |                            
                 +----------------+                            
                 | + execute()    |                            
                 +----------------+                            
                        ^                                                 
                        |                                       
           +------------+----------------+
           |                             |
           |                             |
    +------+--------+      +-------------+-----------------+
    |    Leaf       |      |         Composite             |
    +---------------+      +-------------------------------+
    | ...           |      |  - children: Component[]      |
    +---------------+      +-------------------------------+
    | + execute()   |      | + add(c: Component)           |
    +---------------+      | + remove(c: Component)        |
                           | + getChildren(): Component[]  |
                           | + execute()                   |
                           +-------------------------------+




State
========================================================================
State is a behavioral design pattern that lets an object alter its 
behavior when its internal state changes. It appears as if the object 
changed its class.


+--------------------------------+            +-----------------+
|            Context             |            |  <<interface>>  |
+--------------------------------+          * |      State      |
| - state                        |----------->------------------+
+--------------------------------+            | + action1(data) |
| + Context(initialState)        |            | + action2(data) |
| + Context(initialState)        |            +-----------------+
| + changeState(state)           |                    ^
| + action1(state)               |                    |
| + action2(state)               |                    |
+--------------------------------+                    |
                                                      |
                               +------------------------------------------------+
                               |                      |                         |
                               |                      |                         |
                     +--------------------+  +---------------------+  +--------------------+
                    |  ConcreteStateA     |  |  ConcreteStateB     |  |  ConcreteStateC    |
                    +---------------------+  +---------------------+  +--------------------+
                    | - context           |  | - context           |  | - context          |
                    +-+-------------------+  +-+-------------------+  +-+------------------+
                    | + setContext(ctx)   |  | + setContext(ctx)   |  | + setContext(ctx)  |
                    | + action1(data)     |  | + action1(data)     |  | + action1(data)    |
                    | + action2(data)     |  | + action2(data)     |  | + action2(data)    |
                    +-+-------------------+  +-+-------------------+  +-+------------------+


Proxy
========================================================================
Proxy is a structural design pattern that lets you provide a substitute 
or placeholder for another object. A proxy controls access to the original 
object, allowing you to perform something either before or after the request 
gets through to the original object.

                       +-------------------+
+--------+             |   <<interface>>   |
| Client |------------>|  ServiceInterface |
+--------+             +-------------------+
                       | + operation()     |
                       +-------------------+
                                 ^
                                 |
                                 |                                 
                  +--------------------------+
                  |                          |
     +------------+-----------+      +------------------+
     |         Proxy          |      |    Service       |
     +------------------------+      +------------------+
     | - realService: Service |      | ...              |
     +------------------------+      +------------------+
     | + Proxy(s: Service)    |      | + operation()    |
     | + checkAccess()        |      +------------------+
     | + operation()          |
     +------------------------+


Prototype
========================================================================
Prototype is a creational design pattern that lets you copy existing 
objects without making your code dependent on their classes.


                        +----------------------+
                        |    <<interface>>     |
+--------+              |      Prototype       |
| Client |------------->|----------------------+
+--------+              | + clone(): Prototype |
                        +----------------------+
                                   ^
                                   |
                                   |
                                   |
                    +---------------------------------+
                    |      ConcretePrototype          |
                    +---------------------------------+
                    | - field1                        |
                    +---------------------------------+
                    | + ConcreatePrototype(prototype) |
                    | + clone(): Prototype            |
                    +---------------------------------+
                                   ^
                                   |
                                   |
                                   |
                    +---------------------------------+
                    |      SubclassPrototype          |
                    +---------------------------------+
                    | - field2                        |
                    +---------------------------------+
                    | + SubclassPrototype(prototype)  |
                    | + clone(): Prototype            |
                    +---------------------------------+


Bridge
========================================================================
Bridge is a structural design pattern that lets you split a large class or 
a set of closely related classes into two separate hierarchiesâ€”abstraction 
and implementationâ€”which can be developed independently of each other.

          +---------+
          | Client  |
          +----+----+
               |
               |
 +------------------------------------------------------------- Bridge ------+
 |             |                                                             |
 |             v                                                             |
 |     +---------------------+           +-----------------+                 |
 |     |   Abstraction       |           |  <<interface>>  |                 |
 |     +---------------------+           |  Implementation |                 |
 |     | -i : Implementation +---------->|-----------------+                 |
 |     +---------------------+           | + method1()     |                 |
 |     | + feature1()        |           | + method2()     |                 |
 |     | + feature2()        |           | + method3()     |                 |
 |     +---------------------+           +-----------------+                 |
 |             ^                                ^                            |
 |             |                                |                            |
 +---------------------------------------------------------------------------+
               |                                |
               |                                |
      +--------+-------------+          +-----------------+
      |  Refined Abstraction |          |    Concrete     |
      +----------------------+          | Implementations |
      | ...                  |          +-----------------+
      +----------------------+          
      | + featureN()         |
      +----------------------+

Flyweight
========================================================================
Flyweight is a structural design pattern that lets you fit more objects 
into the available amount of RAM by sharing common parts of state between 
multiple objects instead of keeping all of the data in each object.

Intrinsic state: lives within the object. Other objects can only read it, 
not change it.
Extrinsic state: often altered from the outside by other objects.
The Flyweight pattern suggests that you stop storing the extrinsic state 
inside the object. Instead, you should pass this state to specific methods 
which rely on it. Only the intrinsic state stays within the object, letting 
you reuse it in different contexts. As a result, youâ€™d need fewer of these 
objects since they only differ in the intrinsic state, which has much fewer 
variations than the extrinsic.

+--------------------------------+
|      FlyweightFactory          |
+--------------------------------+                              +--------+
| - cache: Flyweight[]           |<------------------+          | Client |
+--------------------------------+                   |          +----+---+
| + getFlyweight(repeatingState) |                   |               |
+--------------------------------+                   |               |
              | *                                    |               |
              |                                      |               |
              |                                      |               v
              |                                   +----------------------------------------+
              v                                   |               Context                  |
   +---------------------------+                  +----------------------------------------+
   |      Flyweight            |                  | - uniqueState                          |
   +---------------------------+                  | - flyweight                            |
   | - repeatingState          |<-----------------+----------------------------------------+
   +---------------------------+                  | + Context(repeatingState, uniqueState) |
   | + operation(uniqueState)  |                  | + operation()                          |
   +---------------------------+                  +----------------------------------------+
         Intrinsic                                              Extrinsic                                                  


Builder
========================================================================
Builder is a creational design pattern that lets you construct complex
objects step by step. The pattern allows you to produce different types
and representations of an object using the same construction code.
The Builder doesnâ€™t allow other objects to access the product while itâ€™s 
being built.
You can go further and extract a series of calls to the builder steps 
you use to construct a product into a separate class called director. 
The director class defines the order in which to execute the building 
steps, while the builder provides the implementation for those steps.


                           +--------+
     +---------------------+ Client +--------------------+
     |                     +--------+                    |
     |                                                   |
     |                                                   v
     |           +-----------------+         +--------------------------+
     |           |  <<interface>>  |<--------|       Director           |
     |           |     Builder     |         +--------------------------+
     |           +-----------------+         | - builder: Builder       |
     |           | + reset()       |         +--------------------------+
     |           | + buildStepA()  |         | + Director(builder)      |
     |           | + buildStepB()  |         | + changeBuilder(builder) |
     |           | + buildStepZ()  |         | + make(type)             |
     |           +-----------------+         +--------------------------+
     |                    ^
     |                    |
     |        +---------------------------+
     |        |                           |
     v        |                           |
+-------------------------+   +-------------------------+
|       Concrete          |   |      Concrete           |
|       Builder1          |   |      Builder2           |
+-------------------------+   +-------------------------+
| - result: Product1      |   | - result: Product2      |
+-------------------------+   +-------------------------+
| + reset()               |   | + reset()               |
| + buildStepA()          |   | + buildStepA()          |
| + buildStepB()          |   | + buildStepB()          |
| + buildStepZ()          |   | + buildStepZ()          |
| + getResult(): Product1 |   | + getResult(): Product2 |
+-+---------+-------------+   +-+---------+-------------+
            |                             |
            |                             |
            v                             v
       +------------+               +------------+
       |  Product1  |               |  Product2  |
       +------------+               +------------+
